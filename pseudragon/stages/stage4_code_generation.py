"""
Stage 4: Code Generation
4단계: 코드 생성

Implements code generation from the paper (Algorithm 1):
논문의 알고리즘 1에서 코드 생성을 구현합니다:
- Policy-to-Code translation / 정책-코드 변환
- Template-based generation / 템플릿 기반 생성
- Syntax validation / 구문 검증
"""

# Standard library imports
# 표준 라이브러리 import
import ast
from typing import Any, Callable, Dict, Optional

# Project-specific imports
# 프로젝트 관련 import
from pseudragon.domain.policy_dsl import ActionType, Policy


class Stage4CodeGeneration:
    """
    Stage 4: Template-based Code Generation
    4단계: 템플릿 기반 코드 생성

    Generates executable Python code from validated policies using templates.
    검증된 정책에서 템플릿을 사용하여 실행 가능한 Python 코드를 생성합니다.

    Benefits of template-based approach:
    템플릿 기반 접근의 이점:
    - No LLM hallucination / LLM 환각 없음
    - Guaranteed syntax correctness / 구문 정확성 보장
    - Fast generation / 빠른 생성
    - Predictable output / 예측 가능한 출력
    """

    def __init__(self, llm_client=None):
        """
        Initialize code generator
        코드 생성기 초기화

        Args:
            llm_client: Not used in template-based approach (kept for compatibility)
                       템플릿 기반 접근에서는 사용하지 않음 (호환성을 위해 유지)
        """
        self.client = llm_client

    def generate_code(self, schema: Dict[str, Any], policy: Policy, pii_metadata: Dict[str, Any], db_config: Optional[str] = None, log_callback: Optional[Callable] = None, ) -> str:
        """
        Generate Python code from policy using templates.
        템플릿을 사용하여 정책에서 Python 코드를 생성합니다.

        Implements f_code() from Algorithm 1.
        알고리즘 1의 f_code()를 구현합니다.

        Args:
            schema: Database schema information
            policy: Validated policy
            pii_metadata: PII metadata
            db_config: Database connection path or config
            log_callback: Optional logging callback

        Returns:
            Python code as string
        """
        self._log("[Code] [Stage 4] Template-based Code Generation", log_callback)

        # Generate code from template
        code = self._generate_from_template(schema, policy, pii_metadata, db_config)

        # Validate syntax
        code = self._validate_syntax(code, log_callback)

        self._log("✨ Code generation complete!", log_callback)
        return code

    def _generate_from_template(self, schema: Dict[str, Any], policy: Policy, pii_metadata: Dict[str, Any], db_config: Optional[str] = None, ) -> str:
        """
        Generate code using template
        템플릿을 사용하여 코드 생성
        """
        table_name = policy.table_name
        schema.get("columns", [])

        # Build column processing code
        processing_code = self._build_processing_code(policy, pii_metadata)

        # Build imports
        imports = self._build_imports(policy)

        # Build policy documentation
        policy_doc = self._build_policy_documentation(policy, pii_metadata)

        # Build DB connection code
        db_connection_code = self._build_db_connection_code(table_name, db_config)

        # Build encryption initialization code (if ENCRYPT is used)
        encryption_init_code = self._build_encryption_init_code(policy)

        # Generate complete script
        code = f'''"""
Pseudonymization Script for Table: {table_name}
테이블 {table_name}에 대한 가명처리 스크립트

Auto-generated by PseuDRAGON Framework
PseuDRAGON 프레임워크에 의해 자동 생성됨

Policy Summary:
정책 요약:
{policy_doc}
"""

{imports}

{encryption_init_code}

def pseudonymize_data(df):
    """
    Apply pseudonymization policy to dataframe
    데이터프레임에 가명처리 정책 적용

    Args:
        df: Input pandas DataFrame
           입력 pandas DataFrame

    Returns:
        Pseudonymized DataFrame
        가명처리된 DataFrame
    """
    df = df.copy()

{processing_code}

    return df


def main():
    """
    Main execution function
    메인 실행 함수
    """
{db_connection_code}

    # Apply pseudonymization
    print(f"Processing {{len(df)}} rows from table '{table_name}'...")
    df_pseudonymized = pseudonymize_data(df)

    # Save result
    output_file = "pseudonymized_{table_name}.csv"
    df_pseudonymized.to_csv(output_file, index=False, encoding='utf-8-sig')

    print("[OK] Pseudonymization completed successfully!")
    print(f"   Processed {{len(df_pseudonymized)}} rows")
    print(f"   Output saved to: {{output_file}}")

    return df_pseudonymized


if __name__ == "__main__":
    main()
'''

        return code

    def _build_imports(self, policy: Policy) -> str:
        """
        Build import statements based on required actions
        필요한 액션에 따라 import 문 생성
        """
        # Check which actions are used
        actions_used = set()
        for col_policy in policy.columns.values():
            if col_policy.is_pii:
                actions_used.add(col_policy.action.action)

        # Build library installation section for non-standard libraries
        non_standard_libs = []
        if ActionType.ENCRYPT in actions_used:
            non_standard_libs.append("cryptography")

        # Create auto-install section if non-standard libraries are needed
        install_section = []
        if non_standard_libs:
            install_section.append("# Auto-install required non-standard libraries")
            install_section.append("# 필요한 비표준 라이브러리 자동 설치")
            install_section.append("import subprocess")
            install_section.append("import sys")
            install_section.append("")
            install_section.append("def install_required_libraries():")
            install_section.append("    \"\"\"Install required non-standard libraries if not available\"\"\"")
            install_section.append(f"    required_libs = {non_standard_libs}")
            install_section.append("    ")
            install_section.append("    for lib in required_libs:")
            install_section.append("        try:")
            install_section.append("            __import__(lib)")
            install_section.append(f"            print(f\"[OK] {{lib}} is already installed\")")
            install_section.append("        except ImportError:")
            install_section.append(f"            print(f\"[WARN] {{lib}} not found. Installing...\")")
            install_section.append("            try:")
            install_section.append("                subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", lib])")
            install_section.append(f"                print(f\"[OK] Successfully installed {{lib}}\")")
            install_section.append("            except subprocess.CalledProcessError as e:")
            install_section.append(f"                print(f\"[X] Failed to install {{lib}}: {{e}}\")")
            install_section.append(f"                print(f\"  Please manually install with: pip install {{lib}}\")")
            install_section.append("                sys.exit(1)")
            install_section.append("")
            install_section.append("# Install required libraries before importing them")
            install_section.append("install_required_libraries()")
            install_section.append("")

        # Standard imports
        imports = ["import os", "import pandas as pd", "import duckdb"]

        # Add imports based on actions
        if ActionType.HASH in actions_used:
            imports.append("import hashlib")

        if ActionType.MASK in actions_used:
            imports.append("import re")

        if ActionType.TOKENIZE in actions_used:
            imports.append("import uuid")

        if ActionType.ENCRYPT in actions_used:
            imports.append("import base64")
            imports.append("from cryptography.fernet import Fernet")
            imports.append("# Note: Encryption key must be securely managed")
            imports.append("# ENCRYPTION_KEY should be loaded from secure storage")

        # Combine install section and imports
        all_lines = install_section + imports
        return "\n".join(all_lines)

    def _build_encryption_init_code(self, policy: Policy) -> str:
        """
        Build encryption initialization code if ENCRYPT action is used
        ENCRYPT 액션이 사용되는 경우 암호화 초기화 코드 생성
        """
        # Check if any column uses ENCRYPT
        uses_encrypt = False
        for col_policy in policy.columns.values():
            if col_policy.is_pii and col_policy.action.action == ActionType.ENCRYPT:
                uses_encrypt = True
                break

        if not uses_encrypt:
            return ""

        # Generate encryption initialization code
        code = """
# ========================================
# Encryption Setup
# 암호화 설정
# ========================================
# CRITICAL: Encryption key management
# 중요: 암호화 키 관리
#
# The encryption key must be stored securely for later decryption.
# 복호화를 위해 암호화 키를 안전하게 저장해야 합니다.
#
# Production recommendations:
# 프로덕션 권장사항:
# - Store key in secure key management system (AWS KMS, Azure Key Vault, etc.)
# - 보안 키 관리 시스템에 키 저장 (AWS KMS, Azure Key Vault 등)
# - Never commit keys to version control
# - 버전 관리 시스템에 키를 커밋하지 마세요
# - Use environment variables or secret management
# - 환경 변수 또는 비밀 관리 사용
# ========================================

# Generate encryption key (development only)
# 암호화 키 생성 (개발 환경 전용)
key = Fernet.generate_key()
print("=" * 60)
print("[WARN]️  IMPORTANT: Store this encryption key securely!")
print("[WARN]️  중요: 이 암호화 키를 안전하게 저장하세요!")
print("=" * 60)
print(f"Encryption Key: {key.decode()}")
print("=" * 60)
print("Without this key, encrypted data CANNOT be decrypted!")
print("이 키가 없으면 암호화된 데이터를 복호화할 수 없습니다!")
print("=" * 60)
print()

# Initialize Fernet cipher
# Fernet 암호화 객체 초기화
fernet = Fernet(key)
"""
        return code

    def _build_db_connection_code(self, table_name: str, db_config: Optional[str] = None) -> str:
        """
        Build database connection and data loading code
        데이터베이스 연결 및 데이터 로딩 코드 생성
        """
        if db_config:
            # Use provided DB path
            db_path = db_config
        else:
            # Use default sample DB path
            db_path = "KFTC_sample_table_schemas.duckdb"

        code = f"""    # Database connection
    # 데이터베이스 연결
    DB_PATH = r"{db_path}"

    if not os.path.exists(DB_PATH):
        raise FileNotFoundError(f"Database not found: {{DB_PATH}}")

    print(f"Connecting to database: {{DB_PATH}}")
    conn = duckdb.connect(DB_PATH, read_only=True)

    # Load data from table
    # 테이블에서 데이터 로드
    query = "SELECT * FROM {table_name}"
    print(f"Executing query: {{query}}")
    df = pd.read_sql(query, conn)
    conn.close()

    print(f"Loaded {{len(df)}} rows from table '{table_name}'")
"""
        return code

    def _build_processing_code(self, policy: Policy, pii_metadata: Dict[str, Any]) -> str:
        """
        Build column processing code using LLM-generated code snippets from Stage 2
        Stage 2에서 LLM이 생성한 코드 스니펫을 사용하여 컬럼 처리 코드 생성
        """
        code_lines = []

        # First pass: Extract helper functions from complex snippets
        helper_functions = []
        for col_name, col_policy in policy.columns.items():
            code_snippet = col_policy.action.code_snippet
            if code_snippet and '\n' in code_snippet.strip():
                # Check if it contains a function definition
                if 'def ' in code_snippet:
                    # Extract and store helper function
                    helper_functions.append(code_snippet.strip())

        # Add helper functions at the beginning
        if helper_functions:
            code_lines.append("    # Helper functions for complex transformations")
            code_lines.append("    # 복잡한 변환을 위한 헬퍼 함수")
            for func in helper_functions:
                # Indent the function definition properly
                for line in func.split('\n'):
                    code_lines.append(f"    {line}")
                code_lines.append("")  # Empty line after each function
            code_lines.append("")  # Extra empty line before processing code

        # Second pass: Generate processing code for each column
        for col_name, col_policy in policy.columns.items():
            action = col_policy.action.action
            rationale = col_policy.action.rationale
            code_snippet = col_policy.action.code_snippet

            # Get column comment from pii_metadata
            column_comment = pii_metadata.get(col_name, {}).get("column_comment", "")

            # Add comment with policy info
            if column_comment:
                code_lines.append(f"    # {col_name}: {column_comment}")
            code_lines.append(f"    # PII Type: {col_policy.pii_type} | Method: {action.value}")
            code_lines.append(f"    # Rationale: {rationale}")

            # Use LLM-generated code snippet if available
            if code_snippet and code_snippet.strip():
                # Handle DELETE action (column drop)
                if action == ActionType.DELETE:
                    code_lines.append(f"    if '{col_name}' in df.columns:")
                    code_lines.append(f"        df = df.drop(columns=['{col_name}'])")

                # Handle KEEP action (no transformation)
                elif action == ActionType.KEEP:
                    code_lines.append(f"    # No transformation needed for {col_name}")

                # Handle other actions with code snippet
                else:
                    # Clean up code snippet (remove comments if it's just a comment)
                    if code_snippet.strip().startswith("#"):
                        code_lines.append(f"    {code_snippet.strip()}")
                    else:
                        # Convert standalone code snippet to lambda function
                        # LLM generates snippets like: "hashed_x = hashlib.sha256(str(record['x']).encode()).hexdigest()"
                        # We need to convert this to: "lambda x: hashlib.sha256(str(x).encode()).hexdigest()"
                        lambda_code = self._convert_snippet_to_lambda(code_snippet, col_name)

                        # Check if this is a complex snippet that needs a helper function
                        if lambda_code.startswith("__COMPLEX_SNIPPET__"):
                            # Complex snippet - check if it's a function definition with apply()
                            if 'def ' in code_snippet and '.apply(' in code_snippet:
                                # Extract the apply() statement (last line typically)
                                lines = code_snippet.strip().split('\n')
                                apply_line = None
                                for line in reversed(lines):
                                    if '.apply(' in line or f"['{col_name}']" in line:
                                        apply_line = line.strip()
                                        break

                                if apply_line:
                                    # Use the apply() statement directly (function already defined above)
                                    code_lines.append(f"    # Apply transformation using helper function defined above")
                                    code_lines.append(f"    if '{col_name}' in df.columns:")
                                    code_lines.append(f"        {apply_line}")
                                else:
                                    # Fallback: couldn't extract apply line
                                    code_lines.append(f"    # WARNING: Complex snippet - could not extract apply() statement")
                                    code_lines.append(f"    # Original snippet:")
                                    for snippet_line in code_snippet.split('\n'):
                                        code_lines.append(f"    # {snippet_line}")

                            # Check if snippet contains .apply() without function definition
                            # Example: "df['column'].apply(lambda x: str(uuid.uuid4()) if pd.notna(x) else None)"
                            elif '.apply(' in code_snippet:
                                # Extract the lambda from .apply() using parenthesis matching
                                apply_idx = code_snippet.find('.apply(')
                                if apply_idx != -1:
                                    # Find the opening parenthesis after .apply
                                    start_idx = apply_idx + len('.apply(')
                                    # Match parentheses to find the closing one
                                    paren_count = 1
                                    end_idx = start_idx
                                    while end_idx < len(code_snippet) and paren_count > 0:
                                        if code_snippet[end_idx] == '(':
                                            paren_count += 1
                                        elif code_snippet[end_idx] == ')':
                                            paren_count -= 1
                                        end_idx += 1

                                    lambda_expr = code_snippet[start_idx:end_idx - 1].strip()

                                    # Use the extracted lambda directly
                                    code_lines.append(f"    if '{col_name}' in df.columns:")
                                    code_lines.append(f"        df['{col_name}'] = df['{col_name}'].apply(")
                                    code_lines.append(f"            {lambda_expr}")
                                    code_lines.append(f"        )")
                                else:
                                    # Couldn't extract lambda - use as-is
                                    code_lines.append(f"    if '{col_name}' in df.columns:")
                                    # Replace df['col_name'] or df["col_name"] with df['{col_name}']
                                    cleaned_snippet = code_snippet.replace(f"df['{col_name}']", f"df['{col_name}']")
                                    cleaned_snippet = cleaned_snippet.replace(f'df["{col_name}"]', f"df['{col_name}']")
                                    code_lines.append(f"        {cleaned_snippet}")

                            else:
                                # Complex snippet without function definition - comment it out
                                code_lines.append(f"    # WARNING: Complex snippet requires manual integration")
                                code_lines.append(f"    # Original snippet:")
                                for snippet_line in code_snippet.split('\n'):
                                    code_lines.append(f"    # {snippet_line}")
                        else:
                            # Use lambda function
                            code_lines.append(f"    if '{col_name}' in df.columns:")
                            code_lines.append(f"        df['{col_name}'] = df['{col_name}'].apply(")
                            code_lines.append(f"            {lambda_code}")
                            code_lines.append(f"        )")

            else:
                # Fallback to template-based generation if no code snippet
                code_lines.append(f"    # WARNING: No code snippet provided by LLM")
                code_lines.append(f"    # Using fallback template for {action.value}")
                fallback_code = self._generate_fallback_code(col_name, action, col_policy.action.parameters)
                code_lines.extend(fallback_code)

            code_lines.append("")  # Empty line between columns

        return "\n".join(code_lines)

    def _convert_snippet_to_lambda(self, code_snippet: str, col_name: str) -> str:
        """
        Convert standalone code snippet to lambda function for pandas .apply()
        독립형 코드 스니펫을 pandas .apply()용 람다 함수로 변환

        Args:
            code_snippet: LLM-generated code snippet (e.g., "hashed_x = hashlib.sha256(...)")
            col_name: Column name being processed

        Returns:
            Lambda function string or special marker for complex snippets
        """
        # Remove any leading/trailing whitespace
        snippet = code_snippet.strip()

        # Handle multi-line snippets with import statements
        # Extract the actual code (skip import lines)
        if '\n' in snippet:
            lines = snippet.split('\n')
            # Filter out import statements
            non_import_lines = [line for line in lines if not line.strip().startswith('import ')]

            # If we have only one non-import line, process it as a single-line snippet
            if len(non_import_lines) == 1:
                snippet = non_import_lines[0].strip()
                # Continue processing as single-line snippet below
            else:
                # Complex multi-line code (multiple statements)
                # This is a complex snippet that can't be converted to a simple lambda
                # Return a special marker that will be handled differently
                return f"__COMPLEX_SNIPPET__:{col_name}"

        # Single import statement without other code - this is an error
        if snippet.startswith('import '):
            return f"__COMPLEX_SNIPPET__:{col_name}"

        # CRITICAL: Check if snippet already contains .apply() - this means it's a full transformation statement
        # Example: "df['column'].apply(lambda x: str(uuid.uuid4()) if pd.notna(x) else None)"
        # We should NOT wrap this in another lambda - mark it as complex for special handling
        if '.apply(' in snippet:
            return f"__COMPLEX_SNIPPET__:{col_name}"

        # Check if snippet contains assignment (e.g., "hashed_x = ...")
        if "=" in snippet and not snippet.startswith("lambda"):
            # Split by first '=' to get the expression part
            parts = snippet.split("=", 1)
            if len(parts) == 2:
                expression = parts[1].strip()

                # Replace record['column'] with x (the lambda parameter)
                # Handle both single and double quotes
                expression = expression.replace(f"record['{col_name}']", "x")
                expression = expression.replace(f'record["{col_name}"]', "x")

                # Create lambda function with null handling
                return f"lambda x: ({expression}) if pd.notna(x) else None"

        # If snippet is already a lambda or doesn't match expected format, return as-is
        # but add null handling if not present
        if snippet.startswith("lambda"):
            return snippet

        # Fallback: wrap the entire snippet in a lambda (may not work, but better than nothing)
        return f"lambda x: ({snippet}) if pd.notna(x) else None"

    def _generate_fallback_code(self, col_name: str, action: ActionType, parameters: Dict[str, Any]) -> list:
        """
        Generate fallback code when LLM code snippet is not available
        LLM 코드 스니펫을 사용할 수 없을 때 폴백 코드 생성
        """
        fallback_lines = []

        if action == ActionType.HASH:
            fallback_lines.append(f"    if '{col_name}' in df.columns:")
            fallback_lines.append(f"        df['{col_name}'] = df['{col_name}'].apply(")
            fallback_lines.append(f"            lambda x: hashlib.sha256(str(x).encode()).hexdigest() if pd.notna(x) else None")
            fallback_lines.append(f"        )")

        elif action == ActionType.MASK:
            # CRITICAL: MASK requires specific masking rules from legal documents
            # Do NOT use generic fallback - this forces LLM to provide code_snippet
            fallback_lines.append(f"    # ERROR: MASK action requires specific code snippet from legal document")
            fallback_lines.append(f"    # The LLM must extract masking rules (e.g., 'show first 4', 'show last 3')")
            fallback_lines.append(f"    # and generate appropriate code snippet in Stage 2.")
            fallback_lines.append(f"    if '{col_name}' in df.columns:")
            fallback_lines.append(f"        raise ValueError(")
            fallback_lines.append(f"            f'MASK action for {{'{col_name}'}} requires code_snippet from Stage 2. '")
            fallback_lines.append(f"            f'LLM must extract specific masking rule from legal documents.'")
            fallback_lines.append(f"        )")

        elif action == ActionType.DELETE:
            fallback_lines.append(f"    if '{col_name}' in df.columns:")
            fallback_lines.append(f"        df = df.drop(columns=['{col_name}'])")

        elif action == ActionType.TOKENIZE:
            fallback_lines.append(f"    if '{col_name}' in df.columns:")
            fallback_lines.append(f"        df['{col_name}'] = df['{col_name}'].apply(")
            fallback_lines.append(f"            lambda x: str(uuid.uuid4()) if pd.notna(x) else None")
            fallback_lines.append(f"        )")

        elif action == ActionType.GENERALIZE:
            # Generic generalization fallback (reduces precision)
            # Specific generalization logic should come from LLM code snippet
            fallback_lines.append(f"    # WARNING: GENERALIZE requires specific strategy from LLM")
            fallback_lines.append(f"    # Using generic fallback: convert to string representation")
            fallback_lines.append(f"    if '{col_name}' in df.columns:")
            fallback_lines.append(f"        # TODO: Implement appropriate generalization strategy")
            fallback_lines.append(f"        # Examples: age ranges, date truncation, geographic grouping")
            fallback_lines.append(f"        df['{col_name}'] = df['{col_name}'].apply(")
            fallback_lines.append(f"            lambda x: str(x) if pd.notna(x) else None")
            fallback_lines.append(f"        )")

        elif action == ActionType.ROUND:
            # Numeric rounding fallback - preserve original data type
            fallback_lines.append(f"    # ROUND: Reduce numeric precision by rounding (preserving data type)")
            fallback_lines.append(f"    if '{col_name}' in df.columns:")
            fallback_lines.append(f"        # Default: Round to nearest 1000 for integers, 2 decimals for floats")
            fallback_lines.append(f"        # Check if column is integer type to preserve data type")
            fallback_lines.append(f"        is_integer_col = df['{col_name}'].dropna().apply(lambda x: float(x).is_integer()).all() if len(df['{col_name}'].dropna()) > 0 else False")
            fallback_lines.append(f"        if is_integer_col:")
            fallback_lines.append(f"            df['{col_name}'] = df['{col_name}'].apply(")
            fallback_lines.append(f"                lambda x: int(round(float(x), -3)) if pd.notna(x) and str(x).replace('.','').replace('-','').isdigit() else x")
            fallback_lines.append(f"            )")
            fallback_lines.append(f"        else:")
            fallback_lines.append(f"            df['{col_name}'] = df['{col_name}'].apply(")
            fallback_lines.append(f"                lambda x: round(float(x), 2) if pd.notna(x) and str(x).replace('.','').replace('-','').isdigit() else x")
            fallback_lines.append(f"            )")

        elif action == ActionType.ENCRYPT:
            # Encryption fallback using globally initialized Fernet
            fallback_lines.append(f"    # Encrypt column using Fernet (key initialized above)")
            fallback_lines.append(f"    if '{col_name}' in df.columns:")
            fallback_lines.append(f"        df['{col_name}'] = df['{col_name}'].apply(")
            fallback_lines.append(f"            lambda x: fernet.encrypt(str(x).encode()).decode() if pd.notna(x) else None")
            fallback_lines.append(f"        )")

        else:
            fallback_lines.append(f"    # No fallback available for {action.value}")

        return fallback_lines

    def _build_policy_documentation(self, policy: Policy, pii_metadata: Dict[str, Any]) -> str:
        """
        Build policy documentation for code header
        코드 헤더를 위한 정책 문서 생성
        """
        doc_lines = []

        for col_name, col_policy in policy.columns.items():
            if not col_policy.is_pii:
                continue

            action = col_policy.action
            evidence = action.legal_evidence

            doc_lines.append(f"- {col_name} ({col_policy.pii_type})")
            doc_lines.append(f"  Action: {action.action.value}")
            doc_lines.append(f"  Rationale: {action.rationale}")
            if evidence:
                doc_lines.append(f"  Legal Evidence: {evidence}")
            doc_lines.append("")

        return "\n".join(doc_lines)

    def _validate_syntax(self, code: str, log_callback: Optional[Callable] = None) -> str:
        """
        Validate generated code syntax
        생성된 코드 구문 검증
        """

        self._log("  [Search] Validating generated code...", log_callback)

        try:
            ast.parse(code)
            self._log("  [OK] Syntax validation passed", log_callback)
            return code
        except SyntaxError as e:
            self._log(f"  [WARN]️  Syntax error detected: {e}", log_callback)
            raise e

    def _log(self, message: str, callback: Optional[Callable] = None):
        """
        Helper for logging
        로깅을 위한 헬퍼 함수
        """
        if callback:
            callback(message)
        else:
            print(message)
